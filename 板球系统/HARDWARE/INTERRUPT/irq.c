/*********************************************************************************************************************
 * COPYRIGHT NOTICE
 * Copyright (c) 2019,徐氏伟业
 * All rights reserved.
 *
 * 以下所有内容版权均属徐氏伟业所有，未经允许不得用于商业用途，
 * 欢迎各位使用并传播本程序，修改内容时必须保留徐氏伟业的版权声明。
 *
 * @file       		IRQ
 * @company	   		华北理工大学
 * @author     		徐氏伟业
 * @Software 			MDK 5.24a
 * @Target core		STM32F407VET6
 * @date       		2019-01-31
 ********************************************************************************************************************/
#include "headfile.h"
#include "irq.h"


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
              							/// 自己定义的全局变量 ///
const u16 Y_Zhong = 3380;
const u16 X_Zhong = 2940;

short X = 0;					//X实时位置
short Y = 0;					//Y实时位置
short X_Post = 0;			//X控制实时位置
short Y_Post = 0;			//Y控制实时位置
short Last_X = 0;			//X上次位置
short Last_Y = 0;			//Y上次位置
short Speed_X = 0;		//X速度
short Speed_Y = 0;		//Y速度

u8 flag_control = 0;	//控制周期标志位
u8 flag_mode1 = 0;		//mode1演示使能标志位


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------------------------------------------------
//  @brief      基本定时器7中断服务函数
//  @param      void
//  @return     void
//-------------------------------------------------------------------------------------------------------------------
void TIM7_IRQHandler(void)
{ 		
	
	if(TIM7->SR&0X0001)
	{
		TIM7->SR&=~(1<<0);
		
		
		
	}				   
}

//-------------------------------------------------------------------------------------------------------------------
//  @brief      通用定时器2中断服务函数
//  @param      void
//  @return     void
//-------------------------------------------------------------------------------------------------------------------
void TIM2_IRQHandler(void)
{ 		 
	static u8 tim = 0;
	
	if(TIM2->SR&0X0001)
	{
		TIM2->SR&=~(1<<0);
		
		if(flag_mode1)
		{
				tim++;
			
			if((tim)>8)
			{
				tim = 0;
				pid_post_x.Targer = 116;
				pid_post_y.Targer = 114;
			}
			
			
			switch(tim)
			{
				case 4:
					pid_post_x.Targer = 52;
					pid_post_y.Targer = 185;
				break;
				case 5:
					pid_post_x.Targer = 52;
					pid_post_y.Targer = 48;
				break;
				case 6:
					pid_post_x.Targer = 203;
					pid_post_y.Targer = 48;
				break;
				case 7:
					pid_post_x.Targer = 202;
					pid_post_y.Targer = 185;
				break;
				case 8:
					pid_post_x.Targer = 52;
					pid_post_y.Targer = 185;
				break;
			}
		}
		
		

		
		
	}				   
}

//-------------------------------------------------------------------------------------------------------------------
//  @brief      通用定时器3中断服务函数
//  @param      void
//  @return     void
//-------------------------------------------------------------------------------------------------------------------
void TIM3_IRQHandler(void)
{ 		    		  			    
	if(TIM3->SR&0X0001)
	{
		TIM3->SR&=~(1<<0);

		
	}				   
}

//-------------------------------------------------------------------------------------------------------------------
//  @brief      通用定时器4中断服务函数
//  @param      void
//  @return     void
//-------------------------------------------------------------------------------------------------------------------
void TIM4_IRQHandler(void)
{ 		    		  			    
	if(TIM4->SR&0X0001)
	{
		TIM4->SR&=~(1<<0);
		
		
		
	}				   
}

//-------------------------------------------------------------------------------------------------------------------
//  @brief      通用定时器5中断服务函数
//  @param      void
//  @return     void
//-------------------------------------------------------------------------------------------------------------------
void TIM5_IRQHandler(void)
{ 		    		  			    
	if(TIM5->SR&0X0001)
	{
		TIM5->SR&=~(1<<0);
		
		
		
	}				   
}

//-------------------------------------------------------------------------------------------------------------------
//  @brief      USART2串口中断服务函数
//  @param      void					(读取Data Register中的数据后硬件自动清除中断标志位)
//  @return     void
//-------------------------------------------------------------------------------------------------------------------

void USART2_IRQHandler(void)
{
	if((USART2->SR&0x20)!=0)
	{
		
		
	}
}

//-------------------------------------------------------------------------------------------------------------------
//  @brief      USART3串口中断服务函数
//  @param      void					(读取Data Register中的数据后硬件自动清除中断标志位)
//  @return     void
//-------------------------------------------------------------------------------------------------------------------
void USART3_IRQHandler(void)
{
	if((USART3->SR&0x20)!=0)
	{
		
		
	}
}

//-------------------------------------------------------------------------------------------------------------------
//  @brief      USART6串口中断服务函数
//  @param      void					(读取Data Register中的数据后硬件自动清除中断标志位)
//  @return     void
//-------------------------------------------------------------------------------------------------------------------


void USART6_IRQHandler(void)
{	
  u8 Res;
	pid_speed_x.KP = 20;
	pid_speed_y.KP = 20;
	
	pid_speed_x.KD = 0;
	pid_speed_y.KD = 0;
	
	pid_speed_x.Targer = 0;
	pid_speed_y.Targer = 0;
	
	pid_post_x.KP = 0.22;
//	pid_post_x.KI = 0.0005;
	pid_post_x.KD = 0.63;
	
	pid_post_y.KP = 0.22;
//	pid_post_y.KI = 0.0005;
	pid_post_y.KD = 0.63;
	if((USART6->SR&0x20)!=0)
	{
		Res = USART_ReceiveData(USART6);	//读取接收到的数据
		Optical_Flow_Receive_Prepare(Res);
		
		
		if(flag_control)
		{
			flag_control = 0;	//控制周期标志位清除
			
			X_Post = X;		//获取X位置
			Y_Post = Y;		//获取Y位置
			Speed_X = X_Post - Last_X;		//计算X速度
			Speed_Y = Y_Post - Last_Y;		//计算Y速度
			Last_X = X_Post;
			Last_Y = Y_Post;
			
			mode_show1();
			
			PID_Post_Control_X();
			PID_Speed_Control_X();				//X分量速度环输出
			PWM_SetDuty(TIMER4,CH3,Y_Zhong-pid_speed_x.Out);
			
			PID_Post_Control_Y();
			PID_Speed_Control_Y();				//Y分量速度环输出
			PWM_SetDuty(TIMER4,CH4,X_Zhong+pid_speed_y.Out);
		}
		
		
		
	}
}


